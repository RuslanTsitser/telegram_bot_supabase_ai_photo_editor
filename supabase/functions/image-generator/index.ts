console.log(`Function "image-generator" up and running!`);

import { Bot, webhookCallback } from "https://deno.land/x/grammy@v1.8.3/mod.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { processImageGroup } from "./processImageGroup.ts";
import { generateImageWithGemini } from "./src/api/generateImageWithGemini.ts";
import {
  addImageToGroup,
  createImageGroup,
  getImageGroupByMediaId,
  updateGroupCaption,
} from "./src/database/imageGroups.ts";
import { processSuccessfulPayment } from "./src/database/payments.ts";
import {
  getSubscriptionPlan,
  getSubscriptionPlans,
} from "./src/database/plans.ts";
import {
  canUserGenerate,
  decrementGenerationLimit,
  getPremiumStatus,
} from "./src/database/premium.ts";
import { getUserByTelegramId, upsertUser } from "./src/database/users.ts";
import { deleteImageFromStorage } from "./src/storage/deleteImageFromStorage.ts";
import { saveImageToStorage } from "./src/storage/saveImageToStorage.ts";
import { getImageUrlFromTelegram } from "./src/telegram/getImageUrlFromTelegram.ts";
import { createSubscriptionInvoice } from "./src/telegram/subscriptionHandlers.ts";
import { generateFileName } from "./src/utils/storage.ts";

const bot = new Bot(Deno.env.get("BOT_TOKEN") || "");

// Initialize Supabase client
const supabase = createClient(
  Deno.env.get("SUPABASE_URL") ?? "",
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "",
);

bot.on("message", async (ctx) => {
  const chatType = ctx.message.chat.type;
  console.log(`${chatType} message`, ctx.message.chat.id);

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
  await upsertUser(ctx, supabase);

  // Handle successful payment
  if (ctx.message.successful_payment) {
    try {
      const payment = ctx.message.successful_payment;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂
      const result = await processSuccessfulPayment(supabase, payment);

      if (result.success) {
        await ctx.reply(
          `‚úÖ –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω! –ö—É–ø–ª–µ–Ω–Ω—ã–π —Ç–∞—Ä–∏—Ñ: ${result.planName}`,
        );
      } else {
        await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–∞: ${result.message}`);
      }
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞:", error);
      await ctx.reply(
        "‚úÖ –ü–ª–∞—Ç–µ–∂ –ø–æ–ª—É—á–µ–Ω, –Ω–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞.",
      );
    }
  }

  // Handle text messages
  if (ctx.message.text) {
    const message = ctx.message.text;

    if (message === "/start") {
      await ctx.reply(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π. –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∏ —è —Å–≥–µ–Ω–µ—Ä–∏—Ä—É—é –¥–ª—è —Ç–µ–±—è –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ",
      );
      return;
    }

    if (message === "/subscriptions") {
      const plans = await getSubscriptionPlans(supabase);
      let subscriptionMessage = "üí≥ –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∞—Ä–∏—Ñ—ã:\n\n";

      plans?.forEach((plan) => {
        const emoji = plan.price === 0 ? "üÜì" : "üí≥";
        if (plan.type === "subscription") {
          subscriptionMessage += `${emoji} ${plan.name} - ${
            plan.price / 100
          }‚ÇΩ\n`;
        } else if (plan.type === "one_time") {
          subscriptionMessage += `${emoji} ${plan.name} - ${
            plan.price / 100
          }‚ÇΩ\n`;
        }
        if (plan.description) {
          subscriptionMessage += `   ${plan.description}\n`;
        }
        subscriptionMessage += "\n";
      });

      // –°–æ–∑–¥–∞–µ–º inline –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∞—Ä–∏—Ñ–∞
      const keyboard = {
        inline_keyboard: plans?.map((plan) => [{
          text: `üí≥ –ö—É–ø–∏—Ç—å ${plan.name}`,
          callback_data: `plan_${plan.id}`,
        }]) || [],
      };

      await ctx.reply(subscriptionMessage, { reply_markup: keyboard });
      return;
    }

    if (message === "/limits") {
      const userId = ctx.from?.id;
      const user = await getUserByTelegramId(supabase, userId);
      if (!user) {
        await ctx.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω");
        return;
      }
      const premiumStatus = await getPremiumStatus(supabase, user.id);
      if (!premiumStatus) {
        await ctx.reply("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ª–∏–º–∏—Ç–∞—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");
        return;
      }
      let message = `–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å:\n`;
      if (premiumStatus.is_premium) {
        message += `- –ü—Ä–µ–º–∏—É–º –Ω–∞–≤—Å–µ–≥–¥–∞. –î–æ–∫—É–ø–∞—Ç—å –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ`;
      }
      if (premiumStatus.premium_expires_at) {
        const expiresAt = new Date(premiumStatus.premium_expires_at);
        const now = new Date();
        if (expiresAt > now) {
          message += `- –ü–æ–¥–ø–∏—Å–∫–∞ –¥–æ ${expiresAt.toLocaleDateString()}`;
        }
      }

      message +=
        `- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: ${premiumStatus.generation_limit}`;

      await ctx.reply(message);
      return;
    }

    if (!message.startsWith("/")) {
      // TODO: add text message handler. Generate image with Gemini without picture.
      await ctx.reply(
        "–ü—Ä–∏—à–ª–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É –∏ –æ–ø–∏—Å–∞–Ω–∏–µ, —á—Ç–æ–±—ã —è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª –¥–ª—è —Ç–µ–±—è –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ",
      );
      return;
    }
  }

  // Handle photo messages
  if (ctx.message.photo) {
    const mediaGroup = ctx.message.media_group_id;
    const userId = ctx.from?.id;
    const user = await getUserByTelegramId(supabase, userId);
    if (!user) {
      await ctx.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω");
      return;
    }
    const limits = await canUserGenerate(supabase, user.id);
    if (!limits) {
      await ctx.reply("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");
      return;
    }

    if (!limits.canGenerate) {
      await ctx.reply(limits.reason || "–£ —Ç–µ–±—è –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏");
      return;
    }

    // –ï—Å–ª–∏ —ç—Ç–æ –≥—Ä—É–ø–ø–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    if (mediaGroup) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –≥—Ä—É–ø–ø–∞
      let group = await getImageGroupByMediaId(supabase, mediaGroup);

      if (!group) {
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É
        group = await createImageGroup(supabase, mediaGroup, user.id);
        if (!group) {
          await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≥—Ä—É–ø–ø—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π");
          return;
        }
      }

      // –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É
      const photo = ctx.message.photo[ctx.message.photo.length - 1];
      const orderIndex = group.total_images; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–∫ –∏–Ω–¥–µ–∫—Å

      console.log(
        `Adding image to group ${group.id}, order: ${orderIndex}, file_id: ${photo.file_id}`,
      );
      await addImageToGroup(supabase, group.id, photo.file_id, orderIndex);

      // –û–±–Ω–æ–≤–ª—è–µ–º caption –µ—Å–ª–∏ –µ—Å—Ç—å
      if (ctx.message.caption) {
        console.log(
          `Updating caption for group ${group.id}: ${ctx.message.caption}`,
        );
        await updateGroupCaption(supabase, group.id, ctx.message.caption);
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      const newCount = group.total_images + 1;
      console.log(
        `Updating group ${group.id} image count from ${group.total_images} to ${newCount}`,
      );
      await supabase
        .from("image_groups")
        .update({ total_images: newCount })
        .eq("id", group.id);

      // –ñ–¥–µ–º 2 —Å–µ–∫—É–Ω–¥—ã –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≥—Ä—É–ø–ø—É
      setTimeout(async () => {
        try {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≥—Ä—É–ø–ø–∞ –≤—Å–µ –µ—â–µ –≤ —Å—Ç–∞—Ç—É—Å–µ "collecting" (–∑–∞—â–∏—Ç–∞ –æ—Ç race condition)
          const currentGroup = await getImageGroupByMediaId(
            supabase,
            mediaGroup,
          );
          if (currentGroup && currentGroup.status === "collecting") {
            console.log(
              `Processing group ${currentGroup.id} with ${currentGroup.total_images} images`,
            );
            await processImageGroup(
              supabase,
              bot,
              currentGroup.id,
              currentGroup.user_id,
            );
          }
        } catch (error) {
          console.error("Error processing group after timeout:", error);
        }
      }, 2000);

      // –ù–ï –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é - –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã
      return;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ª–æ–≥–∏–∫–∞)
    const photo = ctx.message.photo[ctx.message.photo.length - 1];
    const photoUrl = await getImageUrlFromTelegram(photo.file_id, bot.token);

    if (photoUrl) {
      const caption = ctx.message.caption;
      await ctx.reply("–ü–æ–Ω—è–ª, –≥–µ–Ω–µ—Ä–∏—Ä—É—é —Ñ–æ—Ç–æ...");
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–π API
      const uploadResult = await generateImageWithGemini(
        photoUrl,
        caption || "Generate a description of the photo",
      );
      if (!uploadResult) {
        await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Google AI");
        return;
      }

      try {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Supabase Storage
        const fileName = generateFileName();
        const result = await saveImageToStorage(
          supabase,
          uploadResult.imageData,
          fileName,
        );
        const imageUrl = result?.publicUrl;
        const path = result?.path;

        if (!imageUrl) {
          await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");
          return;
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ URL
        await ctx.replyWithDocument(imageUrl, {
          caption: "–í–∞—à–µ —Ñ–æ—Ç–æ –≥–æ—Ç–æ–≤–æ!",
        });
        if (limits.limit !== -1) {
          await decrementGenerationLimit(supabase, user.id);
        }
        if (path) {
          // delete image from storage
          await deleteImageFromStorage(supabase, path);
        }
      } catch (error) {
        await ctx.reply("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ " + error);
      }
    } else {
      await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–æ—Ç–æ");
    }
  }
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è inline –∫–Ω–æ–ø–æ–∫ –ø–æ–¥–ø–∏—Å–æ–∫
bot.on("callback_query", async (ctx) => {
  if (ctx.callbackQuery.data?.startsWith("plan_")) {
    const planId = ctx.callbackQuery.data.replace("plan_", "");

    const plan = await getSubscriptionPlan(supabase, planId);
    if (!plan) {
      await ctx.answerCallbackQuery("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–∞—Ä–∏—Ñ–∞");
      return;
    }

    await createSubscriptionInvoice(ctx, plan);
  }
});

// Webhook –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ–¥ –æ–ø–ª–∞—Ç–æ–π
bot.on("pre_checkout_query", async (ctx) => {
  console.log("pre_checkout_query received");

  try {
    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ payload
    const payload = ctx.preCheckoutQuery.invoice_payload;
    const [planId, userId] = payload.split("_");

    const user = await getUserByTelegramId(supabase, parseInt(userId));
    if (!user) {
      await ctx.answerPreCheckoutQuery(false, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω");
      return;
    }

    const plan = await getSubscriptionPlan(supabase, planId);
    if (!plan) {
      await ctx.answerPreCheckoutQuery(false, "–¢–∞—Ä–∏—Ñ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω");
      return;
    }

    // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ–ø–ª–∞—Ç—ã
    await ctx.answerPreCheckoutQuery(true);
    console.log("Pre-checkout approved for plan:", planId);
  } catch (error) {
    console.error("Error in pre_checkout_query:", error);
    await ctx.answerPreCheckoutQuery(false, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–ª–∞—Ç–µ–∂–∞");
  }
});

bot.on("edited_message", async (_) => {
  // TODO: add edited message handler
});

/// set up the webhook and timout for the bot 4 minutes
const handleUpdate = webhookCallback(bot, "std/http", "throw", 4 * 60 * 1000);

Deno.serve(async (req) => {
  try {
    const url = new URL(req.url);
    if (
      url.searchParams.get("secret") !==
        Deno.env.get("BOT_FUNCTION_SECRET")
    ) {
      return new Response("not allowed", { status: 405 });
    }

    return await handleUpdate(req);
  } catch (err) {
    console.error(err);
  }
});
