console.log(`Function "image-generator" up and running!`);

import { Bot, webhookCallback } from "https://deno.land/x/grammy@v1.8.3/mod.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { processImageGroup } from "./processImageGroup.ts";
import {
  generateImageFromText,
  generateImageWithPiapi,
} from "./src/api/generateImageWithPiapi.ts";
import { onboarding } from "./src/bot/onboarding.ts";
import {
  addImageToGroup,
  createImageGroup,
  getImageGroupByMediaId,
  updateGroupCaption,
} from "./src/database/imageGroups.ts";
import { processSuccessfulPayment } from "./src/database/payments.ts";
import {
  getSubscriptionPlan,
  getSubscriptionPlans,
} from "./src/database/plans.ts";
import {
  canUserGenerate,
  decrementGenerationLimit,
  getPremiumStatus,
} from "./src/database/premium.ts";
import {
  getUserByTelegramId,
  getUserLanguage,
  upsertUser,
} from "./src/database/users.ts";
import { getImageUrlFromTelegram } from "./src/telegram/getImageUrlFromTelegram.ts";
import { createSubscriptionInvoice } from "./src/telegram/subscriptionHandlers.ts";
import { createI18n } from "./src/utils/i18n.ts";

const bot = new Bot(Deno.env.get("BOT_TOKEN") || "");

// Initialize Supabase client
const supabase = createClient(
  Deno.env.get("SUPABASE_URL") ?? "", // TODO: add supabase url
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "", // TODO: add supabase service role key
);

bot.on("message", async (ctx) => {
  const chatType = ctx.message.chat.type;
  console.log(`${chatType} message`, ctx.message.chat.id);

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
  await upsertUser(ctx, supabase);

  const userLanguage = await getUserLanguage(supabase, ctx.from?.id || 0);
  const i18n = createI18n(userLanguage);

  // Handle successful payment
  if (ctx.message.successful_payment) {
    try {
      const payment = ctx.message.successful_payment;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂
      const result = await processSuccessfulPayment(supabase, payment);

      if (result.success) {
        await ctx.reply(
          i18n.t("payment_success", { planName: result.planName || "" }),
        );
      } else {
        await ctx.reply(
          i18n.t("payment_error", { message: result.message || "" }),
        );
      }
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞:", error);
      await ctx.reply(i18n.t("payment_received_error") || "");
    }
  }

  // Handle text messages
  if (ctx.message.text) {
    const message = ctx.message.text;

    if (message === "/start") {
      await onboarding(ctx, supabase);
      return;
    }

    if (message === "/subscriptions" || message === "/subscriptions_test") {
      const plans = await getSubscriptionPlans(supabase);
      const isTest = message === "/subscriptions_test";
      const subscriptionMessage = isTest
        ? i18n.t("subscriptions_test_title")
        : i18n.t("subscriptions_title");

      // –°–æ–∑–¥–∞–µ–º inline –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∞—Ä–∏—Ñ–∞
      const keyboard = {
        inline_keyboard: plans?.map((plan) => [{
          text: `üí≥ ${plan.name} –∑–∞ ${plan.price / 100}‚ÇΩ`,
          callback_data: isTest ? `plan_test_${plan.id}` : `plan_${plan.id}`,
        }]) || [],
      };

      await ctx.reply(subscriptionMessage, { reply_markup: keyboard });
      return;
    }

    if (message === "/limits") {
      const userId = ctx.from?.id;
      const user = await getUserByTelegramId(supabase, userId);
      if (!user) {
        await ctx.reply(i18n.t("user_not_found"));
        return;
      }
      const premiumStatus = await getPremiumStatus(supabase, user.id);
      if (!premiumStatus) {
        await ctx.reply(i18n.t("limits_not_found"));
        return;
      }
      let message = `${i18n.t("limits_title")}\n`;
      if (premiumStatus.is_premium) {
        message += `- ${i18n.t("premium_active")}. –î–æ–∫—É–ø–∞—Ç—å –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ`;
      }
      if (premiumStatus.premium_expires_at) {
        const expiresAt = new Date(premiumStatus.premium_expires_at);
        const now = new Date();
        if (expiresAt > now) {
          message += `- ${
            i18n.t("subscription_expires", {
              date: expiresAt.toLocaleDateString(),
            })
          }`;
        }
      }

      message += `- ${
        i18n.t("free_generations")
      } ${premiumStatus.generation_limit}`;

      await ctx.reply(message);
      return;
    }

    if (!message.startsWith("/")) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ —Ç–µ–∫—Å—Ç—É
      const userId = ctx.from?.id;
      const user = await getUserByTelegramId(supabase, userId);
      if (!user) {
        await ctx.reply(i18n.t("user_not_found"));
        return;
      }

      const limits = await canUserGenerate(supabase, user.id);
      if (!limits) {
        await ctx.reply(i18n.t("generation_info_not_found"));
        return;
      }

      if (!limits.canGenerate) {
        await ctx.reply(limits.reason || i18n.t("no_access"));
        return;
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –ø—É—Å—Ç–æ–µ
      if (!message.trim()) {
        await ctx.reply(i18n.t("text_generation_empty_prompt"));
        return;
      }

      await ctx.reply(i18n.t("text_generation_processing"));

      try {
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ —Ç–µ–∫—Å—Ç—É
        const result = await generateImageFromText(message.trim());

        if (!result) {
          await ctx.reply(i18n.t("text_generation_error"));
          return;
        }

        const url = result.imageData;

        if (!url) {
          await ctx.reply(i18n.t("generation_save_error"));
          return;
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ URL
        await ctx.replyWithPhoto(url);
        await ctx.replyWithDocument(url, {
          caption: i18n.t("text_generation_success"),
        });

        // –£–º–µ–Ω—å—à–∞–µ–º –ª–∏–º–∏—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–π
        if (limits.limit !== -1) {
          await decrementGenerationLimit(supabase, user.id);
        }
      } catch (error) {
        console.error("Error generating image from text:", error);
        await ctx.reply(
          i18n.t("text_generation_error"),
        );
      }
      return;
    }
  }

  // Handle photo messages
  if (ctx.message.photo) {
    if (ctx.message.caption === "file_id" && chatType === "private") {
      const fileId = ctx.message.photo[0].file_id;
      await ctx.reply(fileId);
      return;
    }

    const mediaGroup = ctx.message.media_group_id;
    const userId = ctx.from?.id;
    const user = await getUserByTelegramId(supabase, userId);
    if (!user) {
      await ctx.reply(i18n.t("user_not_found"));
      return;
    }
    const limits = await canUserGenerate(supabase, user.id);
    if (!limits) {
      await ctx.reply(i18n.t("generation_info_not_found"));
      return;
    }

    if (!limits.canGenerate) {
      await ctx.reply(limits.reason || i18n.t("no_access"));
      return;
    }

    // –ï—Å–ª–∏ —ç—Ç–æ –≥—Ä—É–ø–ø–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    if (mediaGroup) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –≥—Ä—É–ø–ø–∞
      let group = await getImageGroupByMediaId(supabase, mediaGroup);

      if (!group) {
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É
        group = await createImageGroup(supabase, mediaGroup, user.id);
        if (!group) {
          await ctx.reply(i18n.t("generation_upload_error"));
          return;
        }
      }

      // –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É
      const photo = ctx.message.photo[ctx.message.photo.length - 1];
      const orderIndex = group.total_images; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–∫ –∏–Ω–¥–µ–∫—Å

      console.log(
        `Adding image to group ${group.id}, order: ${orderIndex}, file_id: ${photo.file_id}`,
      );
      await addImageToGroup(supabase, group.id, photo.file_id, orderIndex);

      // –û–±–Ω–æ–≤–ª—è–µ–º caption –µ—Å–ª–∏ –µ—Å—Ç—å
      if (ctx.message.caption) {
        console.log(
          `Updating caption for group ${group.id}: ${ctx.message.caption}`,
        );
        await updateGroupCaption(supabase, group.id, ctx.message.caption);
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      const newCount = group.total_images + 1;
      console.log(
        `Updating group ${group.id} image count from ${group.total_images} to ${newCount}`,
      );
      await supabase
        .from("image_groups")
        .update({ total_images: newCount })
        .eq("id", group.id);

      // –ñ–¥–µ–º 2 —Å–µ–∫—É–Ω–¥—ã –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≥—Ä—É–ø–ø—É
      setTimeout(async () => {
        try {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≥—Ä—É–ø–ø–∞ –≤—Å–µ –µ—â–µ –≤ —Å—Ç–∞—Ç—É—Å–µ "collecting" (–∑–∞—â–∏—Ç–∞ –æ—Ç race condition)
          const currentGroup = await getImageGroupByMediaId(
            supabase,
            mediaGroup,
          );
          if (currentGroup && currentGroup.status === "collecting") {
            console.log(
              `Processing group ${currentGroup.id} with ${currentGroup.total_images} images`,
            );
            await processImageGroup(
              supabase,
              bot,
              currentGroup.id,
              currentGroup.user_id,
              user.telegram_id,
            );
          }
        } catch (error) {
          console.error("Error processing group after timeout:", error);
        }
      }, 2000);

      // –ù–ï –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é - –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã
      return;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ª–æ–≥–∏–∫–∞)
    const photo = ctx.message.photo[ctx.message.photo.length - 1];
    const photoUrl = await getImageUrlFromTelegram(photo.file_id, bot.token);

    if (photoUrl) {
      const caption = ctx.message.caption;
      await ctx.reply(i18n.t("generation_processing"));
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–π API
      const uploadResult = await generateImageWithPiapi(
        photoUrl,
        caption || "–í–µ—Ä–Ω–∏ —Ç–∞–∫–æ–µ –∂–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –º—É–ª—å—Ç—è—à–Ω–æ–º —Å—Ç–∏–ª–µ",
      );
      if (!uploadResult) {
        await ctx.reply(i18n.t("generation_error"));
        return;
      }

      try {
        const url = uploadResult.imageData;

        if (!url) {
          await ctx.reply(i18n.t("generation_save_error"));
          return;
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ URL
        await ctx.replyWithPhoto(url);
        await ctx.replyWithDocument(url, {
          caption: i18n.t("generation_success"),
        });
        if (limits.limit !== -1) {
          await decrementGenerationLimit(supabase, user.id);
        }
      } catch (error) {
        await ctx.reply(
          i18n.t("generation_process_error", { error: String(error) }),
        );
      }
    } else {
      await ctx.reply(i18n.t("generation_photo_error"));
    }
  }
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è inline –∫–Ω–æ–ø–æ–∫ –ø–æ–¥–ø–∏—Å–æ–∫
bot.on("callback_query", async (ctx) => {
  let planId: string;
  let isTest: boolean;

  if (
    ctx.callbackQuery.data?.startsWith("plan_") ||
    ctx.callbackQuery.data?.startsWith("plan_test_")
  ) {
    if (ctx.callbackQuery.data?.startsWith("plan_test_")) {
      isTest = true;
      planId = ctx.callbackQuery.data.replace("plan_test_", "");
    } else {
      isTest = false;
      planId = ctx.callbackQuery.data.replace("plan_", "");
    }

    const plan = await getSubscriptionPlan(supabase, planId);
    if (!plan) {
      await ctx.answerCallbackQuery("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–∞—Ä–∏—Ñ–∞");
      return;
    }

    await createSubscriptionInvoice(ctx, plan, isTest);
  }
});

// Webhook –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ–¥ –æ–ø–ª–∞—Ç–æ–π
bot.on("pre_checkout_query", async (ctx) => {
  console.log("pre_checkout_query received");

  try {
    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ payload
    const payload = ctx.preCheckoutQuery.invoice_payload;
    const [planId, userId] = payload.split("_");

    const user = await getUserByTelegramId(supabase, parseInt(userId));
    if (!user) {
      await ctx.answerPreCheckoutQuery(false, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω");
      return;
    }

    const plan = await getSubscriptionPlan(supabase, planId);
    if (!plan) {
      await ctx.answerPreCheckoutQuery(false, "–¢–∞—Ä–∏—Ñ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω");
      return;
    }

    // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ–ø–ª–∞—Ç—ã
    await ctx.answerPreCheckoutQuery(true);
    console.log("Pre-checkout approved for plan:", planId);
  } catch (error) {
    console.error("Error in pre_checkout_query:", error);
    await ctx.answerPreCheckoutQuery(false, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–ª–∞—Ç–µ–∂–∞");
  }
});

bot.on("edited_message", async (_) => {
  // TODO: add edited message handler
});

/// set up the webhook and timout for the bot 4 minutes
const handleUpdate = webhookCallback(bot, "std/http", "throw", 4 * 60 * 1000);

Deno.serve(async (req) => {
  try {
    const url = new URL(req.url);
    if (
      url.searchParams.get("secret") !==
        Deno.env.get("BOT_FUNCTION_SECRET")
    ) {
      return new Response("not allowed", { status: 405 });
    }

    return await handleUpdate(req);
  } catch (err) {
    console.error(err);
  }
});
